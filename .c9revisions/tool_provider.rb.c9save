{"ts":1361732892270,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1361732929546,"patch":[[{"diffs":[[1,"require 'sinatra'\nrequire 'ims/lti'\n# must include the oauth proxy object\nrequire 'oauth/request_proxy/rack_request'\n\nenable :sessions\nset :protection, :except => :frame_options\n\nget '/' do\n  erb :index\nend\n\n# the consumer keys/secrets\n$oauth_creds = {\"test\" => \"secret\", \"testing\" => \"supersecret\"}\n\ndef show_error(message)\n  @message = message\n  erb :error\nend\n\ndef authorize!\n  if key = params['oauth_consumer_key']\n    if secret = $oauth_creds[key]\n      @tp = IMS::LTI::ToolProvider.new(key, secret, params)\n    else\n      @tp = IMS::LTI::ToolProvider.new(nil, nil, params)\n      @tp.lti_msg = \"Your consumer didn't use a recognized key.\"\n      @tp.lti_errorlog = \"You did it wrong!\"\n      return show_error \"Consumer key wasn't recognized\"\n    end\n  else\n    return show_error \"No consumer key\"\n  end\n\n  if !@tp.valid_request?(request)\n    return show_error \"The OAuth signature was invalid\"\n  end\n\n  if Time.now.utc.to_i - @tp.request_oauth_timestamp.to_i > 60*60\n    return show_error \"Your request is too old.\"\n  end\n\n  # this isn't actually checking anything like it should, just want people\n  # implementing real tools to be aware they need to check the nonce\n  if was_nonce_used_in_last_x_minutes?(@tp.request_oauth_nonce, 60)\n    return show_error \"Why are you reusing the nonce?\"\n  end\n\n  # save the launch parameters for use in later request\n  session['launch_params'] = @tp.to_params\n\n  @username = @tp.username(\"Anonymous\")\nend\n\n# The url for launching the tool\n# It will verify the OAuth signature\npost '/lti_tool' do\n  authorize!\n\n  if @tp.outcome_service?\n    # It's a launch for grading\n    erb :assessment\n  else\n    # normal tool launch without grade write-back\n    @tp.lti_msg = \"Sorry that tool was so boring\"\n    erb :boring_tool\n  end\nend\n\n# post the assessment results\npost '/assessment' do\n  if session['launch_params']\n    key = session['launch_params']['oauth_consumer_key']\n  else\n    return show_error \"The tool never launched\"\n  end\n\n  @tp = IMS::LTI::ToolProvider.new(key, $oauth_creds[key], session['launch_params'])\n\n  if !@tp.outcome_service?\n    return show_error \"This tool wasn't lunched as an outcome service\"\n  end\n\n  # post the given score to the TC\n  res = @tp.post_replace_result!(params['score'])\n\n  if res.success?\n    @score = params['score']\n    @tp.lti_msg = \"Message shown when arriving back at Tool Consumer.\"\n    erb :assessment_finished\n  else\n    @tp.lti_errormsg = \"The Tool Consumer failed to add the score.\"\n    show_error \"Your score was not recorded: #{res.description}\"\n  end\nend\n\nget '/tool_config.xml' do\n  host = request.scheme + \"://\" + request.host_with_port\n  url = host + \"/lti_tool\"\n  tc = IMS::LTI::ToolConfig.new(:title => \"Example Sinatra Tool Provider\", :launch_url => url)\n  tc.description = \"This example LTI Tool Provider supports LIS Outcome pass-back.\"\n\n  headers 'Content-Type' => 'text/xml'\n  tc.to_xml(:indent => 2)\nend\n\ndef was_nonce_used_in_last_x_minutes?(nonce, minutes=60)\n  # some kind of caching solution or something to keep a short-term memory of used nonces\n  false\nend\n"]],"start1":0,"start2":0,"length1":0,"length2":3062}]],"length":3062,"saved":false}
